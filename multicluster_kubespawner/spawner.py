import asyncio
import subprocess
import tempfile
from io import StringIO
from jinja2 import Template
from textwrap import dedent
import string
import escapism
from ruamel.yaml import YAML

yaml = YAML(typ="safe")

from jupyterhub.spawner import Spawner
from traitlets.config import Unicode


class MultiClusterKubernetesSpawner(Spawner):
    objects_template = Unicode(
        "",
        help="""
        Jinja2 Template to generate kubernetes objectes generated by the spawner
        """,
        config=True,
    )
    key_template = Unicode("jupyter-{{username}}--{{servername}}", config=True)

    @property
    def template_vars(self):
        # Make sure username and servername match the restrictions for DNS labels
        # Note: '-' is not in safe_chars, as it is being used as escape character
        safe_chars = set(string.ascii_lowercase + string.digits)

        raw_servername = self.name or ""
        safe_servername = escapism.escape(
            raw_servername, safe=safe_chars, escape_char="-"
        ).lower()

        safe_username = escapism.escape(
            self.user.name, safe=safe_chars, escape_char="-"
        ).lower()
        params = dict(
            userid=self.user.id,
            username=safe_username,
            unescaped_username=self.user.name,
            servername=safe_servername,
            unescaped_servername=raw_servername,
        )

        # Key depends on other params here, so do it last
        params["key"] = Template(self.key_template).render(**params).rstrip("-")
        return params

    @property
    def key(self):
        return self.template_vars["key"]

    def get_labels(self):
        """
        Default labels added on to all objects generated by this spawner
        """
        return {
            "mcks.hub.jupyter.org/key": self.key,
        }

    def modify_pod(self, pod):
        notebook = next(c for c in pod["spec"]["containers"] if c["name"] == "notebook")

        # Inject our environment variables into the notebook container
        env = notebook.setdefault("env", [])
        for k, v in self.get_env().items():
            env.append({"name": k, "value": v})

        return pod

    def get_objects_spec(self):
        """
        Render the templated YAML
        """
        params = self.template_vars.copy()
        params["env"] = self.get_env()
        rendered = Template(dedent(self.objects_template)).render(**params)
        parsed = list(yaml.load_all(rendered))

        for p in parsed:
            # Inject metadata into every object
            labels = p.setdefault("metadata", {}).setdefault("labels", {})
            labels.update(self.get_labels())

            if p["kind"] == "Pod":
                p = self.modify_pod(p)
        return parsed

    async def kubectl_apply(self, spec):
        proc = await asyncio.create_subprocess_exec(
            "kubectl",
            "apply",
            "-f",
            "-",
            stdin=asyncio.subprocess.PIPE,
            stdout=asyncio.subprocess.PIPE,
        )

        with StringIO() as s:
            yaml.dump_all(spec, s)
            s.seek(0)
            obj = s.read()
        print(obj)
        stdout, stderr = await proc.communicate(obj.encode())
        print(stdout, stderr)

        await proc.wait()
        if proc.returncode != 0:
            raise ValueError(f"kubectl apply failed: {stdout}, {stderr}")

    async def kubectl_wait(self):
        proc = await asyncio.create_subprocess_exec(
            "kubectl", "wait", "--for=condition=Ready", f"pod/{self.key}"
        )
        await proc.wait()

    async def start(self):
        print("hi")
        spec = self.get_objects_spec()
        print(spec)
        await self.kubectl_apply(spec)
        print("wat")
        await self.kubectl_wait()

        return "http://34.69.164.86"
        # return "http://192.168.64.3:32258"

    async def stop(self):
        proc = await asyncio.create_subprocess_exec(
            "kubectl",
            "delete",
            "all",
            "-l",
            f"mcks.hub.jupyter.org/key={self.key}",
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )
        stdout, stderr = await proc.communicate()
        print(stdout, stderr)

    async def poll(self):
        pass
